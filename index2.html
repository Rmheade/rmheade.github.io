<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"918d6a8afae13dc9ff21b48cbaf76b1649834ace723407ba3b57a04b96b2dd786e354293b99166f009d3169e7bc1be46350648504b92ab283203445861caaa3f37f2a7a603077485e92dd144b7091601c6919764e5e07071c8421a928a1992de0e59eb566c346be79ab85527b5e42d9a76410175474a703ea663d74adecfa08e3149d43856b1803865643d30f4940622a2e60362e8cf85a8054f31920ea3ee7b8e7ccaac33960489c4e85630203688d77fe138416e6940a0d4188d9a103b260f159cf400b1f07fdb5f03fbac6f047ba402b60e627ccd13c1ad43f10f2ba86de6fb86237ca1992c17723d8baaebd7c241a39a9dc723130bf09ee1d573720dd809b5c6223e0aa398133e46adb1a756d330cc1d6552d48f801610de88249a394530ba472a5a3847b48a2391a9dc30e65400ce90a9d0e9fc91d0b4a6d41751ff093bd8723b8cc9ceee868ac3b88c732eb49453b1e1d9e2a0351b4d57c15cfe2666d8f99cf00498d030809e3a6ef0e187b2489963c2bbd2d25351656df0ec3878ca12f83093b4fa6939bc7f9d8691c4ef8b5cbf61a19b280a1e725e208fdb74eb3e992654283758826f926da052f0171175d0270a98f9e1206059c048b6e9eaafd6405063ea1f5dfd7b38dd844a95e2350aceaf5d5a8819230c07b999ab44cb7e5ccc769bf3d1769f0871c581a650cc4e4fae26eee93d1cf00b44e45af849177aed0942a2835d82169b70e35ace7dd0febb6b4cb28c3e597dbde864173ba317bdbfb44d40d577b8fc1d14cf656e63b4cd2cb99b217669c34a1fde35bd6ee64b7e5908313d33c40a3ee9b1fafe73a61d531a0191d141d6f86e97e77560e8ffc057680dbe3a908a544577773ca57445329c63e1cd95fdd6b6e4f768b98396574117f71637b36cd3ee62c2dc569c64d7dce5604807c831f08aba64967ff0924b6ec7655613db7f3a2d8d477530975478dd8bd015f3254f0c95e1010924379eb1ef2b8aea212c3679d987594c45fa0eb9a96cec7a30c7a9e0995c30500ea862972454682330fa0954268a8b30b8ef6e3eb9170a2639b9ad1f599de5425c3e091dab4f195482f2d324117d3951a3a641b57a6ebcc2fc804a86f220e9f8009d59c668014d14e9f40dede846fbe51c4fe4d2bc9db88e0861a6b2041714a2f4dc4c604c3b45563c887fab79227bbb62f649469ff9da0006a7d6466f5fd493aefc3a0034c0d1a04596427e9c7865dfcc836525224a68424e0ad8d1ba9173885dfd73c0cdfe86ced3a381215f3d4d249e822ad53b835cdfa2090f0083d41e30c994011b54d75c52a43a3e5643ec8f24b4f43b02839433cc49c1864fe806e551adf7320288115d2b7819fd01e224ff93e0222c48707c65d174bd2209b6bf62667d532d2906bf045fa243053f26de563ff424a81da71b1ffc3979591b4e210d69cef47c6a4730dda6f645e2f91fb3b472a081235911796c9f56362e24471f587a51b0b15fc795427d940db6f154e71da1980036f10047dddbe6d2ba2a09e841453b6d03502826711319cae73326fbec0c23346d5ef6a470cafff13ff6b192a57506210f31b5c2a8376ac7026ddc5e5cbbe30bc9ba4c1b424be229fa52d5b28800adcad747fe4bfa290610e874d554d751f935077f859ae96f419fce4f0c369db18a56e0d43e8aa21977776f0e92e40318e3ea6519a1c47389838e7ca8a09a53f9a3d627b6a572a30fff55a7ef737537059900c5084c3585b6692f6fe2e30eb350d9fbfd80706200b8e5d884e58075a99ec02e9ac0c91bf51e7c3936527e92ecfd5ae988d3fe4b44ee782b4540adcddfe792cf9a5ebc4c2e5bba1297b9b60ff6004a9d2cabe6758c0b51ee09d158b16dae5ee910c8355fb496e2670a11c16c835a9b806c66fe68d95ca4137e2c53b455969c2d43f88d068130c4e4587fbf130e6165fe7f2225d66260da257f3d11b559361a76a995a795cae14a100be60f1ae8de9c6b1448913ce51fb0e5675ed7d4e58820c5d13e98b41e97ffa25d2a51cd73d729bf2030ac6efcd5fa26674d5da50cc2dd5834dd893bc326e7a4f58ac371da67c82b7387bd65c52645931df281efac2e1e641d48e52b08f1659d471719944c5640c691e9afbcf481c3c3616d4f20f32910b2ea024f68fe7815485bd50731956ba85a61e4b0a9b6d8715a154fe6b92921b5f299c9b0e4c2d6db13f65e13b672ce14026777c1cf9cc507be3c2b24047de5f35c0410231376c552ba5de64e5032e8a66439a81b666231288f742f864f962c0f1419e7f655cda8247c389d5c968b64cabef5110b4df4181362be2817cfef8b1158359779383a66990171877cdd312f81333c582fb4a382c4c57f833e7261c94528e4144a8d0545ea6c38acadbe1ad60e67c7310207c915c5427deb3d54726d327fc04274a50327d1bf242a663d92f50542820de109e9bc85cf29afb173d04de9589500330c9a5283ef17791306b840d8f8d9df70d843607af34a4a84368cfe25b85e37708a16a23b40e84032e75e3b4bffa83b158f32b6d74c46f0e897282a54827931d63a8f89cf59a7ab44db7c793006c6ea00e73180bbd30aeba1f52f3f02c6afc1288745b02f24f08f98fa8e428ec81358ef87bbf3af26d2cd9ede44b0969e0392588035f98ef04dc7d3e7b8337e9361aef93275ee06709c64b14e961ac92a2a5435a4026cf2326e0fc880a5db1f2beab5eb75bfd2f48226a75f73bb94b586ad747129e6bfbb8c543305cbf0f874a3a73352eaa516a5959178bae861efc77b9baccb5b092abd921101d8c1d1771737e032d90909351f01a1e45aaeb39e49b40db1232eff809bd8393123c0e01757e1fd98892325f3eee350bc2853e4ee07cb2e07ef58eef906ee60fd26def4fc43e1b61c0ff0286d38ff405ba8539a728e9327c1890d40d5e59dcc38303ac93a2cb12f42a2f35f0a7a31545b5d95aaa0d0d1e2126be01706a4560296ac588cc7285f9c97ccb93411ef8db446beaa4a9aa4dc45953a6ae2f761c0e61ddaf19831decfc3b4d7ce06678cdcff2f4ea22744fa0315e48ea0ea98c0a22c98715cbafb5b3c7248d28507806d0b1f82d50ded98ea72dc2c590fbf666e874b57a7bdc76fdf798b9cf18ec9fc21df684675addb67990db77ae745ac4e93dab7f5a27e61e59e443207a56a97afe80302445f9c1d6873b6aaed38540a902d2aaf9fdc86971f106222519b4b43b15fad97c038a8bfa56ee92854298c3debfe3fe4fca7a201c4a34b8babefdd1945bf6c6bd056de852f0642d66c684d88a61e7c1a27e393561c1d752c4fd4805cfb6385f14cf4e1dead847f52164b50651056b70bb500e4af5fce10dcc31cc5c504b3f13bf7eda023892233a1a227d30952298eb7b389e2282530bf4ea19e744b04ea501fab3f642a29d0cf61010646aa33055e73921a8e672a898c2f9a4d3b3ae15828611c01e2657694796ce325c1f72c154b9c296425dbe89e3a508f240a132a3a5a449e4601c3b9e3b8152b877b069a32a3264e413fc46b066c7b32ce0d80034e826d2e14ce9347aad7bfc7f3f4b7dbdeb9226a605ea8335a5bb241002c3cef3ccab43b7229f8b7c831b416edcfeada4a5ec986496d5b8b26b5483fe2717af235c7041cce77eaa8c2122b603363b0907d51391210c1b288f068a81ed762e5e5c69d07b321b10690a30f8d52e13714b42580ee0b743a5388e4cfd12febebe1614c77fd1ee4a7bc97b2ff10162e5d94f9f741d0c25884404135e733e38c92173cf8de1972c51f2164de9e22356c77a40f88e513d42fdbe929fbc32e2a51c162a0e7fcd5c192738225334a698618f7e2c1379fe183081c347434ae687a93eb260c41bc679e32e112432d0c551248f348ee6076f4a0638222ecdc3ca39b2b97915bfe8eaeba2ab84f59d8576450d64d45c004fbd13bd861f44ca41af9fa85c5567f37689a93ee07a413682b3b2bd31784c72d53e0015fe6ed52b70518cd98f56cfd75c40873d73f3585e4e7c00f0e107d9b8e577ed91b8c6866f99ddffd853bfd670087c9058214252a65d742f5db054299a070d485bce995afa7d310e32b338f92ae268f988ca24efa3ff0d1e2dc0c77630407747957da496adf656e9e603e2fea4d7350330da6d479927da11ebb01c8cd4f5e9d31ce2c6f636e16a6ee12d05eb0032bec869e3ac945fa1016918090d284db0242620300949e4bfdb89052edff70c22baeb23700ae0425b8ab9a1d5ed0c2dc637f0990e2a2e31dabf3e5d358fe86b18948437869298e0591429310f64e4c7a159f9bdb82c6c27bfc07d26d446554e092ec420c5c19024ebecf829c8f03c525b28c2846b1c63b6a537358f2cdcb2ee761ffb981b2e40bb337bd0f549b8e355fee92d3647a1f43f99f443a419f055683613abeb79809486af858bec7da7a314ad0882435dea5d1d0b062a6ab1eb96ef4fdb02f678babed0779bee29ebbcd2750cbdb7a0c427a8372183ac1358380d7e1d11cb8d3912cb62148ddb0a02ae742f8d0688add89b2fe88ff76c5b0486549c0e721e3967a4ab675e3681d81b68d21cbc61a374562f44bd6117a2ceb7200096de9c0c4b1a72e1f60b25972de7599567582b8f06a14ee7165adb743d4e55e165538566aa5dbc3cd8732cf032abc51c87c9f8f6c8bb60c7dbad3fbfe30d26842390dcdb316f701cfcf53db9099c78b5fc76e81aafb28368772a55ace707cf6be53cc00c0827be6945d9bcc2d67507b0d7383d42a353c5b8c4528080be773175b81570fd7da955210a7d229a159d74190bfc69a53ef602e97c95aa9da89991c6c8e747a2c43aa756d77098845855e7aa0b9fcfdbaf11d737ffd320438002c9fb63eabb2dc2f6da1eea9d64e54d06a32a706a5899baa907ec591112681e130b6503d0ff474a02600db75ae18cc32d210c6dda31b73708d809f2ec336c37b764ffa076d23e95462a3e9dba5c7c7f16c5924f5891b446603e52c07fce6b2c8b4e988aa34bf15735c18b0ccb28241ec1f2bad50e6f897320807edfdea09486a7ba070ec5f64aca257b89ecb48517bb7ba4411461b66bbbacfd25169a093ebcdc1dc450e09d4cede83811b8412399584fb8ee35927dbb73c3da623ad95604556dbe1afda8ebb10c147e3546c8206f1bbd73354113abb7cf1830a18aeba1baccb982ef5be585ffb90b8d0c78fb309d28fe4e720496fee9182fb9453f3695b638773c89706ec093ef523fcbbc9578e4eb372538289505539c5783a4e960997c8c8be80d0e8d49457ad707ac26908c3f73fc4afe11af5f638114c150bba68b2e88390020c86762d03e44511fd3e94975dc3278882397fae1620393708daa39861121b1c562f55d973bba2a5f19d93d56bd500bc28f866cd7688d2f8056f4f6171ce2094ff305347d679c4c97f6fe57a24f749b7ca6e6138d8ae30ed4f34e3f5379ad7cbd7f31fb1ea0804a6caba63dc55041360712ea6dc74dc66241ffbd60a343a2e0b4d0b9e70f5a22ba5c4fa827339c834a83538a97ef0e0a59079dfc2845a1b3fcb35e5b8d76622da2bb2a887ee7928f69cdf2f14bdc4411c2575b36591801fb40912eec7ec3626ae719bf0d5a5a022afa2c7c04f6a6af67069fc7f7e01e7ff2c54bcfd1d248a84e042be18c21673aa6089853a495bce165ef51325a07a4578a1459de3a2f7eef4eb94be4d445c537f6667213561da68728c04cf3fca8529feb4ae7d63af1b65d6f06ad8ab24fe337c39b556a517b1b2edbdba1f6e3a5437fbd49aebb9fe40c34d2585430101b2b518df8d7ebb3385aea49934c88a0eb3dd9c7ea5b9321f18f3d90c94c7ef096fa4cdf0ee65552f127e71cbbb6ce6f8aba62f1024477cf3ac2681442201f8d8a3aa2b486ac6d1c68e342d5c67ff840279c20037eabc794209c0d73a611a6cf631e20e75ef71d94134993b59c167268ee88e26e85daf60a5702812919a3bb4f8782b122e635d381d03515276b10d10319a56ceea64d849904c86cc35442d9fa4bcfe1629e132e18264f74966acfb43fe94e7d85b8216fc8d41c31f1f3ac17ce948984b16f95f44acb2d18d48d9d692b01fde26ee8b4761cca87cb6be91e5046f694617b517b072b9a8ee092796a015537c538fb25e19160c929d23229aba9d833c5494045b4d012d993ae0394110678379c60cdc8634d2713a153c51b5c2e9bff9d2f54a81f469f647f40c3056b72fbb69fc5a07c5a22e865e84ea133226c5d0239ca58fcd2542d2171fb47da1131e5b029f6b2ae20d1ff6a76a9dce622cf514540c2a931a593ea98eb43a57a0725b05526454a8149a92f04858dc5329a143ab6f31e0c32577fd94cfd8b2aa0d071823ac080148cf44aaad6a8ccb4ec37258d5bd51e003752f7df80335913d7d9b191be42dcf7b17314ee0d58dc4ebdc1e5d433d3d1611e2be5a37c71ea78749c509c4b57a96d22429169c57a4b23b66e44f3b7cad201d035b8962feb78299ee9a546aaffbd9f08b341bed9954ce57d2744115198993bbed150aca72b6eeb0171ea2859d6b0e78c92ca7c6941dc2a2b87e186381c37b6c931ee7e4d4deea9d476a8a23e6429af292e5513762de8d8c5a221e8f3019e4ee75d9a97e8db588b7f4c53dbd00a9311707c30380f4b3f0b5c01ee49cfca40a0249e6d0775ee5d46aa71ffe0d52272daee51c3e3ff00316d1dd290077e6d1d6792ed440ba6fafa10f24f071490e891e576030b1336ece1c9a17ed021f0053277cd45d062637afa09d2f5cf7cc7f25623bda1c40bc63abb8764e098b37100e00cdb6c8d83547926ec9611ecc88cacd2e7913d3471518668f7d0e794fc0c12f57ac473bcd55ffbf052181862e19acc9471df169f97e8fc8c65d6c3aa17e06b6ec97cc383dae187a8dd9d58413c4f4e847b1e223d364e62adbbc6fbc8d54eb88266d520744a56bf1d7ca7ac00b15894647b3d1bcc04483c84d6d6ae81fce5b5261bfa2bbd5bceacb0336686c54d1b7fcaabd640709b9d65d339496909a8885949ab97adbf0948ca89e0cf5f8a15a68ea06ad5df165cdc9b7993007cc723cff48ce7669f7f9370489272cc72909482f9e513f37e4456b69f17f1335f48e6e2eeee1410f7ecb13531585275e37974dc73c72efa56bc08da31767933966f0e53ab781939be287d3e0fde4094cd24e71703729c08060e89af8d00e3f1dc7fec6c46f02691f15f52911214f76b41880d26228034c37676a9ece90ce04e398dcae8a75b0cc903c8de1c02d15bd3cfe4cdd7b1ff23e235f0f3157f05ad81621db5222ad36e86a6a478f38c7f8ed96ae21074a9369dc2d7b7ed7fc58ff71f92c9261be004cb8410be8d12932a56d6263df73db1d9718aaa63d29130dfb278162741a1c98b54c4ab6bf92d6213ab08df9febd3689bbdedfad17123a4eebc42ee8f52a5921b28ecdfa28979a8b13b514432e6094753ab10842c05c5ccbdbedddd802451084fe082f2f1a26a34e6a3e38cb61a64f0a20ce948e410c5b28e532bf51cebb558a96d59b579b6bceb699a92412f6f6dbc1b535022e5f85b37fa27106566e81b65cb3f9d69b0d38cc7b5dd91533a3efeeedf3f5d0610fe70deddbbbc144a386aa5434923533966fd28b76bb45b30f8228952222baf2b8770d3743f0a70bc69a580a2c1392e58e6699b64f266fbaa23aaabc0173b84987eb6791bdc94ab9f5004b868010d403fe71a065cebfe5bad46d7cefecd88d18fcec310f5770f4c28998a13eac61bd90cec22d29d4030e5ec1aed76db6e1e8dfd9808da27cd0692bcd6294383afd35c76c9f55873d487e4820c453549889e84db3562790ab56da49bd7befc57ca6b0256b4a7917251a11fd8178a804977601eb90bb43ba66f9f5bef1eb4b901586841803f73524b9c4fc5a03be0c1a6307fa954a80a4b3a8fdc3316013fc614738e87cb517ff25b31632005bfa46ec1bc3dcc84fe9ba24b93396997933a9a49dfb873b48c827662ad85427873d27df4147675ec2458373799b968fe2152ed3d0a2b7fb3b213189923d0e4d72139d7128dcf0e6eb6c1223682782bb9464425e3fae4f162d865603362b3dc0d1acce42862f7b081d4c39c8117734f97ed25c9a0f6b1ff438c3b620141629fd1806c463235a2f68940960ccc3732f4733c47d82a27023301e86f11cb565340ba1c561dcef16fcf455675ab539826cd5e163d536a3713c78462d759a55859f814fd3ace633f36a1c69d0fda35d5afc385fb101d1d761c09b8d623521f0e9a0d09fc768fe42d5b54c33af9a43120f770db6da5c290e4dea0285a05d1d99fad8f72842aec59f812641c2702851a0a858d3b003738c6ddc9e4672d5fc86e0a96e10bd544c621039bb2032165f9195b8e75be00aa469415c4afddd836f7362ec0669df648cafeea31e999537a033d5560fd705c9c77946ea22a7f239b602a2a78ad1e0b5daa86cb4796eae4515c5c16e82a19acf506b2ca85e9ccc1d1ab48d2fbe3fe5a4660ed069bd02424aa604c96a67ec51e941cecda10425dea3b3c09464e5868a8538f65679ff492cf008512e41bca44ad4f713718abb414cef033452f6aa835f475d313f42945face6201bd800ef16c24e0ae1f85dbb929c8bd64d944e6d009df7aa044b55e336da680ca63c54df0075a518f7379c6fe9c403a535f9fb0616531ad7cb9ce6e7c12590e1dce53d949e9b8c8a5d50f5b47ba3551e7dc840a0735a966405c36b1056f12d3ffa53d8b06f1b3ea49de76909747df5de761de48d88a83b2a2f2a2d6772da3bbd8baee8473783fe1a6cbca77afdb4a0b86d6ab025b19226fa5d08285eb975118ab943364f9befbd069ae2648e44fdfd36b0dd14bc8daf8a58ce88a9ed059844ace4113a784e64b031ada2e00bc1048a7932a0aea8f24d03731f2adeb431a6681f2ef5ddd680725dc86bb7dca07d2e816ed6166372220064989e8f8143618412d9d7af3414eb21a755c941333ec13a3e2bde7ef1c4530893840bf505b4594e45334ad1474790eb63aa42c801d7508f3ba46e15448339294abc2d11ff0e532f8b7c36078a4c7f90c1753e382a0a23e6fa51600035a3a3bce9c091b284700bd225ee4bac7a2f331e7720a506bdc92415fffe70fd2bb1430926a2acd34cc089e07fbbaecf0a3ed5cdcf7347d036c051509ac4a28d920053760a504b59964182973d95c3105ecaf6b9a1c93019a589a1dd05e8cc48dfc42c05c192a3779477dc7e7b646be5285c5776f2c1a7aa72e22805352f60cd632a7d68259e5895af13865fcdc3aedc71c7516b008b01427f20cfa41ade5ff7a82c5cd884192bbef7cd7fa05fe6a292545bf3e054469eb1fb77c9ba04b555788ee0a91d3e11434ffcf35a3f6a5cd703ff08729fc8adf3ec185f5c4c365b31ea240ce6e9eebcc7e83584f8694712ab51d89f8b435e304db0b1c46a8e51d3554e660685043dbc2c8c582db4354211be979d59189e5bd8ce768b8a836ed33d0a0680933f82d46033c0dcb184f81bd037fed6ac6c28a40791c01969575d3ec7fc9c61e8fc0e3e806af58a3f7528ab7cffc1b38b6d5483b4ee8134e0398822d35da28c2b73ac45a6feb9d433abd9d7419f59602f8611129acf9cc4fd73b19a73b94ea4cbcfed7b1d5f81d9ef6508699fe71a267e93b11760f5cc164a73cf068c23198319c335d439d4c4ca30a4df70468b5946eca81cdf75a791f90bd62501d8ee67cc5fe5263e03da0c099204571a4cbe4d14a51af713f352a17c8f2d463a672b84ade2beca47c2b3269e07674a7a61ad7aa0f038dadfebc6937c6f56084082af728f367c2d46ede197f24aa1630bfc0f89766dd9a09a2a6496bf119413021fa4ea86025fbffdb1d34f390b116f3f05058c27afc03a1d31a89b624192758677a5a5c90637a0a03bedd3c6fa93b700b3ed43dbd7c532bba66cefa4d8ef8cd7ea54c41a3337147241f0c973efdc82884a9e57a6d620fdca21ede35917d5d116c20a800c6c3d8eb5ea3caaed0de8715a26827de0ed74e0f8eea6789165bbe9575ce01bb2f4bc6dc6826d647c73a68b902cb3fc315a591e77d161917b02e1a415183cea8489231bd6a602d37b3edbd27d4702de4a5fff2c5660e28766a9b16d36808d57bfc4fd33aaf8a700d452afa88d7fc8493a56a19f5a5a7d6ce0fef3e2ddf38353ddaf83c23d0c8eeb70196129a194b0465e796cd90427ed2e3395d8a8f04a4733d1753ede5f02fc6468cf65714a10b6bd27b49764a2995dbcb1327d67795516da76c80882a29824fc1a3c477e71ddbf78f07bad0c86e4b47311ec266da4b09dee7f26e0ec69bb3e7b68182fbbdebcd1f623b95d09b6148a31e67db24317ee8dd883d8b5bbe8a96b38695f49d9aaa94ae329976cfd77866375893a47ad72146ca3d743a16cb49248968b8d71a42757527890449aff5e0342ef7e05b0439461f285cad77eecf1e75a724bbd2317e623eba9765dc02fd158e9eb27d4c1a2052952a604640146d04da10528da963220e963851fad8dac230557ae8d18a8176b3b7c5117e6cc64689c56a51caeeebb6d06540899453de27a44d09b04295968dad50e90a165291261f58f3a113fc90d5a795ea580409757b335753691108313a4a6ebc0b7f5136d34c600fd6c0774cd64c700ede2b31ad2f1aae7f57fb6667f7bfd2c6af5bb94e84ae287fb78b1b17a5d7a2c272e4c2b80d7eb41788148daf2aa30943a04cefb8464933ca65bbb5df19c7f2532c6dfb8fb8a0b5173cf199ce675acdb10df50a44ebba0e028cb3b6e5cfa92cb262605a84b7b0ce56ed8d0ed9d2e69a940810c7c605bd1ebf28cc7ab6186793806a0cf745eaea8ef0a541542777d6a7b5c37a1bee90ea9625d04b8a786fa0bbd4509980e5b4de39446785ecf9f2acea8d41b921356023e0c7893d6849c36fd15692136a6091cb9e6207ddebc1335e87bda293fdebb86861661f4e0829e843a4d34ca4dc2b8d6aa2ba468ec5ac5f50b69a1921f6d95d24e652436821cf567763f1c36cb8e75c325f652109119b13738ac7cd030fc95d4ed0beeafd636f6fbe64ef17017a4506c36622fe86adeef5bb32864656943102c1082d9c58d5a0f374352d448880ad3c1dab746dbf16dd7aba96e00fadb57de539c4f1a8a95ab9c33623226dac2eea718a1fd5ab3554dcffbd01ddd3817175802faf0ac14fa703603b89b7a325e89cbeb5d27e5f1e1406123842863bfaaca5073474f5b15e784e487a80cf9f62376be07d17ce8e8d4e49c836ed9439e276d82d99584fcf9e5d689b24209634a12c9335a31ca761fed1782f00a25031928482af8933fc7706af2fd6709307f271f466150f4bed55c8f39496442269252c0e5928fb540ad5b8bea7d77a9c95d7be3e3e5bfaef212c1fe3622fdda7559af536b97e04f1b6796e2d0bdc08bca3c7f53416260e79765800f4f40cb073fc5ef99ae9ee1422701c06c80acecacaa87bcc50d0538939bfb5df3a45929e465ffd45c6ec2729c618b29ae0a","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"52b96c413cbfce5117bae43cbcc741e3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
